.NET Coding Guidelines

## Code Structure & Design
• **Prioritize simplicity and clarity** - Write self-documenting code with descriptive names and SOLID principles
• **Follow proper naming conventions** - Use PascalCase for public members/types/namespaces, camelCase for parameters
• **Maintain single responsibility** - Classes and methods should have one clear purpose and reason to change
• **Keep cyclomatic complexity below 10** - Refactor complex methods with nested loops or multiple conditionals
• **Achieve high cohesion, low coupling** - Related functionality together, minimal dependencies between classes
• **Limit file size to 400 lines** - Break large files into smaller, logically separate components
• **Use interfaces strategically** - Create only when multiple implementations exist or for dependency inversion

## Code Quality & Maintenance
• **Eliminate code duplication (DRY)** - Extract reusable logic into shared components rather than copy-paste
• **Maintain high maintainability index** - Regularly refactor to improve code clarity and reduce complexity
• **Replace magic numbers with constants/enums** - Use well-defined constants for better readability
• **Comment public APIs thoroughly** - Explain external usage for public classes, methods, and properties
• **Include default cases in switch statements** - Handle unexpected input gracefully with default treatments

## Error Handling & Resource Management
• **Implement robust exception handling** - Catch specific exceptions, integrate with logging, never use empty try-catch blocks
• **Use `using` statements for disposables** - Properly manage resources like I/O objects to prevent memory leaks
• **Perform null checking** - Use nullable reference types (C# 8+) and check objects before usage
• **Avoid unsafe code** - Use pointers only when absolutely necessary for the solution

## Asynchronous Programming
• **Favor async/await over threads** - Use for I/O operations with deterministic behavior and easier management
• **Never block async code** - Avoid `.GetAwaiter().GetResult()` or `.Wait()` to prevent deadlocks
• **Don't fake async** - Only use async/await for truly asynchronous operations, not CPU-bound work

## Architecture & Patterns
• **Leverage dependency injection** - Use DI for cleaner code, proper lifetimes, and easier testing
• **Apply Clean Architecture principles** - Domain → Application → Infrastructure dependency flow
• **Use generics for type safety** - Implement flexible, reusable components with compile-time type checking
• **Consider Domain-Driven Design** - Organize complex systems into bounded contexts with clear domain models
• **Apply CQRS when appropriate** - Separate read/write models when storage and query requirements differ significantly

## Performance & Optimization
• **Optimize object allocation** - Minimize large object creation and garbage collector impact
• **Implement caching strategies** - Use backend caching and asynchronous programming for performance
• **Choose appropriate service lifetimes** - Select Singleton, Scoped, or Transient based on state and usage patterns

## Development Process
• **Integrate static analysis tools** - Use Code Metrics, SonarAnalyzer, and similar tools in development workflow
• **Proactively refactor** - Improve poorly tested, duplicated, or tightly coupled code regularly